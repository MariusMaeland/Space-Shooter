Technical

One of the requirements was that all moving objects in the game should sub-class
pygames sprite module. The pygame Sprite module is designed to make simple game 
design easier for developers. It includes built in functions for referring to 
and working with coordinates, displaying images for a better graphical look as
well as detecting collisions and working with objects/sprites in groups. 

Sprite groups is practical because it makes the use of polymorphism very easy.
The sprite module has a built in draw function which blits each sprites "image" 
attribute on a surface. We have also used this to simplify per frame update calls
on many different objects.

Allthough not a specific requirement, we have implemented and thoroughly enjoyed 
making animations with sprite sheets. Linking the actual code and the image 
files has given us valuable insight into how code interacts with "the outside world".
Cutting specific sections of a sprite sheet proved difficult at times, as each sheet
had a different layout, size, padding, alpha channels etc. 

Implementation
The assignment was written in python using Sublime Text build 3103 on Linux Mint 17
”Qiana” and Linux Xubuntu 14.04 running kernel version 3.13.0-24-generic GNU/Linux. 
It also uses the pygame-library.

The various images and sprite sheets have all been edited using 
GIMP(GNU Image Manipulation Program). 

Profiling tools pydoc and cprofiler. 
%TODO: Add more!

Discussion
During tha writing of this assignment we have endeavoured to keep the architecture 
simple and easily understandable. In addition, we wanted it to be easy to expand with 
new ideas and elements. One of the reasons for working in a team was to experience 
how to manage one project with more writers. This forced us to carefully considder 
how encapsulation is handled. It must be possible for one person to work on some 
part of the code and the other works on another part, without worrying about 
making changes that ruin both writers contributions. As a result, the code has a 
fairly solid design on the whole. The game-class manages all the other classes 
as well as their interactions with each other(mainly when they crash!). 

The explosion-class is a good example of solid and reusable code. It takes in a
list of the frames to animate the explsion(this can then be any animation you like)
as well as the point where you want it and the size. This made it very simple to
animate explsions when asteroids blow up, players die etc. The puff of dust when 
asteroids bump into eachother, is also an instance of the explosion-class.

A similar concept is used for the power ups as they are all instances of the animation-class
They each get sent a different coloured list of frames to animate the crystals as well
as placement and size. 

A possible improvement on the explosion and animation would be to have a more general 
animation parent-class from which one could make power ups, explosions and so on 
inherit.

Loading images and cutting subsurfaces from a sprite-sheet are heavy operations,
therefore we have tried to do most of the loading in the game-class setup-method.
The preloaded lists are then sent to each class where they are needed. The actua 
cutting of the animation-sheets are mostly done using nested for-loops to traverse
the image. We made some attempts at abstracting this process out as it is done 
several times. This proved difficult however because of great variasions in the 
layout of the sprite-sheets. As a result, the setup-method has it's own sheetcutter
method, there's aslo a general img_list and some for-loops. This is a bit messy and
should have been abstracted out or the sprite-sheets could be changed to fit 
within a chosen standard. 

Another small but very important part of the optimisation of the code is in the
many collision check method in game. We wanted the presicion of the collide_mask 
which returns the first pixel to overlap between two sprites, this is obviously a heavy operation and should be limited. The collision therefore checks collisions using the collide_rect which is a lot faster, and only then proceeds to check for overlapping pixels.

----------------------------------------------------------------------------------------------------------------------
Thu Apr 14 14:18:28 2016    cProfile

         16112337 function calls in 643.904 seconds

   Ordered by: call count
   List reduced from 101 to 10 due to restriction <10>

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
  2011182    0.554    0.000    0.554    0.000 {method 'colliderect' of 'pygame.Rect' objects}
  2011182    1.845    0.000    2.399    0.000 sprite.py:1287(collide_rect)
  1492992    2.168    0.000    2.168    0.000 sprite.py:303(sprites)
  1446336    1.930    0.000    4.135    0.000 sprite.py:339(__iter__)
  1446336    0.444    0.000    0.444    0.000 {built-in method iter}
  1230017    1.079    0.000    1.079    0.000 precode.py:21(__init__)
   797797    0.324    0.000    0.324    0.000 {built-in method sqrt}
   797797    1.959    0.000    2.283    0.000 precode.py:70(magnitude)
   618347  344.058    0.001  344.058    0.001 {method 'blit' of 'pygame.Surface' objects}
   352654    0.701    0.000    1.001    0.000 precode.py:32(__add__)

Thu Apr 14 14:18:28 2016    cProfile

         16112337 function calls in 643.904 seconds

   Ordered by: internal time
   List reduced from 101 to 10 due to restriction <10>

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
   618347  344.058    0.001  344.058    0.001 {method 'blit' of 'pygame.Surface' objects}
    23328  102.980    0.004  102.980    0.004 {built-in method flip}
   113309  101.839    0.001  101.839    0.001 {built-in method rotate}
   153064   25.605    0.000   25.605    0.000 {built-in method from_surface}
   263887   13.013    0.000   13.013    0.000 {built-in method scale}
    37664   10.847    0.000   10.847    0.000 {method 'copy' of 'pygame.Surface' objects}
    36189    4.425    0.000  134.391    0.004 player.py:202(rotate_sprite)
    23328    4.039    0.000   14.607    0.001 game.py:161(collisionchecks)
   139968    2.228    0.000   16.848    0.000 asteroid.py:31(update)
  1492992    2.168    0.000    2.168    0.000 sprite.py:303(sprites)





 
    
